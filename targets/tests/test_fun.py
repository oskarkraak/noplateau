# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import pytest
import fun as module_0


def test_case_0():
    int_0 = 947
    int_1 = module_0.fibonacci(int_0)
    assert (
        int_1
        == 225331897728885386831385907404374792487729316726237735896487366037775430145267263939265712977397493337008882180748529437982082901232330048377499158577905215949788844686333663613677308751130190276103
    )


def test_case_1():
    str_0 = "LHa&\x0cz\t~\n"
    list_0 = module_0.find_anagrams(str_0, str_0)


def test_case_2():
    str_0 = "'-2kB0&d~/"
    int_0 = module_0.shortest_path(str_0, str_0, str_0)
    assert int_0 == 0


def test_case_3():
    str_0 = "0"
    float_0 = module_0.parse_and_evaluate_expression(str_0)
    assert float_0 == pytest.approx(0.0, abs=0.01, rel=0.01)


def test_case_4():
    str_0 = "L6$N/y%\x0bt[M!.yW3`42"
    float_0 = module_0.parse_and_evaluate_expression(str_0)
    assert float_0 == pytest.approx(6.0, abs=0.01, rel=0.01)


def test_case_5():
    pass


def test_case_6():
    bool_0 = True
    int_0 = module_0.fibonacci(bool_0)
    assert int_0 == 0


def test_case_7():
    str_0 = "'-2kB0&d~/"
    list_0 = [str_0, str_0, str_0, str_0]
    bool_0 = True
    int_0 = module_0.fibonacci(bool_0)
    assert int_0 == 0
    list_1 = module_0.find_anagrams(str_0, list_0)


def test_case_8():
    str_0 = "b+756*(@73O!K.)\x0cwj&2"
    float_0 = module_0.parse_and_evaluate_expression(str_0)
    assert float_0 == pytest.approx(902.0, abs=0.01, rel=0.01)


@pytest.mark.xfail(strict=True)
def test_case_9():
    str_0 = "L6$N/y%\x0bt[M!.yW3`42"
    float_0 = module_0.parse_and_evaluate_expression(str_0)
    assert float_0 == pytest.approx(6.0, abs=0.01, rel=0.01)
    bool_0 = True
    dict_0 = {float_0: float_0, bool_0: str_0, str_0: float_0, bool_0: bool_0}
    int_0 = module_0.shortest_path(dict_0, bool_0, bool_0)
    assert int_0 == 0
    str_1 = "|L!ypt0]l8o0I)jt}s:!"
    int_1 = 1596
    int_2 = module_0.add_numbers(int_1, bool_0)
    assert int_2 == 1597
    module_0.parse_and_evaluate_expression(str_1)


def test_case_10():
    str_0 = "I&s<\rW\rv^M\t#sX"
    bool_0 = module_0.is_palindrome(str_0)
    assert bool_0 is False
    bool_1 = False
    int_0 = module_0.add_numbers(bool_1, bool_0)
    assert int_0 == 0
    int_1 = 2
    int_2 = module_0.fibonacci(int_1)
    assert int_2 == 1


@pytest.mark.xfail(strict=True)
def test_case_11():
    int_0 = 711
    int_1 = module_0.add_numbers(int_0, int_0)
    assert int_1 == 1422
    str_0 = "|L6$N/y%\x0bt[M!.yW`42"
    float_0 = module_0.parse_and_evaluate_expression(str_0)
    assert float_0 == pytest.approx(0.14285714285714285, abs=0.01, rel=0.01)
    module_0.parse_and_evaluate_expression(float_0)


def test_case_12():
    str_0 = "L6$N/y%\x0bt[M!.yW3`42"
    float_0 = module_0.parse_and_evaluate_expression(str_0)
    assert float_0 == pytest.approx(6.0, abs=0.01, rel=0.01)
    bool_0 = True
    dict_0 = {float_0: float_0, bool_0: str_0, str_0: float_0, bool_0: bool_0}
    int_0 = module_0.shortest_path(dict_0, bool_0, bool_0)
    assert int_0 == 0
    with pytest.raises(ValueError):
        module_0.fibonacci(int_0)


def test_case_13():
    str_0 = "'-2kB0&d~/"
    list_0 = [str_0, str_0]
    with pytest.raises(ValueError):
        module_0.shortest_path(list_0, list_0, str_0)


def test_case_14():
    str_0 = "243wymtyn6l"
    float_0 = module_0.parse_and_evaluate_expression(str_0)
    assert float_0 == pytest.approx(243.0, abs=0.01, rel=0.01)
    bool_0 = True
    int_0 = module_0.fibonacci(bool_0)
    assert int_0 == 0
    dict_0 = {float_0: float_0, bool_0: str_0, str_0: float_0, bool_0: bool_0}
    str_1 = ',sSw\t!"'
    with pytest.raises(ValueError):
        module_0.shortest_path(dict_0, bool_0, str_1)


@pytest.mark.xfail(strict=True)
def test_case_15():
    str_0 = "L6$N/y%\x0bt[M!.yW3`42"
    str_1 = "]Kl,fvI6?\n${y"
    float_0 = module_0.parse_and_evaluate_expression(str_1)
    assert float_0 == pytest.approx(6.0, abs=0.01, rel=0.01)
    float_1 = module_0.parse_and_evaluate_expression(str_0)
    assert float_1 == pytest.approx(6.0, abs=0.01, rel=0.01)
    str_2 = "7mge\\B(6L/.!%b@kb&/4"
    module_0.parse_and_evaluate_expression(str_2)


@pytest.mark.xfail(strict=True)
def test_case_16():
    str_0 = "L6$N/y%\x0bt[M!.yW3`42"
    bool_0 = True
    dict_0 = {bool_0: bool_0, bool_0: str_0, str_0: bool_0, bool_0: bool_0}
    module_0.shortest_path(dict_0, bool_0, str_0)


def test_case_17():
    str_0 = "L6$N/y%\x0bt[M!.yW3`42"
    float_0 = module_0.parse_and_evaluate_expression(str_0)
    assert float_0 == pytest.approx(6.0, abs=0.01, rel=0.01)
    dict_0 = {float_0: float_0, str_0: str_0, str_0: str_0, float_0: float_0}
    with pytest.raises(ValueError):
        module_0.shortest_path(dict_0, str_0, float_0)


@pytest.mark.xfail(strict=True)
def test_case_18():
    str_0 = "L6$N/y%\x0bt[M!.)W3`\\2"
    module_0.parse_and_evaluate_expression(str_0)


@pytest.mark.xfail(strict=True)
def test_case_19():
    str_0 = "L6$N/y%\x0bt[M!.yW3`42"
    float_0 = module_0.parse_and_evaluate_expression(str_0)
    assert float_0 == pytest.approx(6.0, abs=0.01, rel=0.01)
    bool_0 = True
    dict_0 = {float_0: float_0, bool_0: str_0, str_0: float_0, bool_0: bool_0}
    int_0 = module_0.shortest_path(dict_0, bool_0, bool_0)
    assert int_0 == 0
    int_1 = module_0.add_numbers(bool_0, int_0)
    assert int_1 == 1
    str_1 = "w>tTb/b;G _/e "
    module_0.parse_and_evaluate_expression(str_1)
